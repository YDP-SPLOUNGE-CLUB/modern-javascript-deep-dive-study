## 4.1 변수란 무엇인가? 왜 필요한가?

> 변수는 프로그래밍 언어에서 데이터를 관리하기 위한 핵심 개념이다.
> 변수란 무엇인지 그리고 왜 필요한지 살펴보자.

```javascript
10 + 20
```

> 위 식을 계산하려면 10, 20 + 라는 기호의 의미를 알고 있어야 하며, 해석도 가능해야한다.
> 자바스크립트 엔진이 10 + 20 이라는 식의 의미를 해석하면 + 연산을 수행하기위해
> 먼저 + 연산자의 좌변과 우변의 숫자 값, 피연산자를 기억한다. 컴퓨터는 연산과 기억을 수행하는 부품이 나뉘어져 있다.
> 컴퓨터는 CPU를 사용해 연산하고, 메모리를 사용하여 데이터를 기억한다.
> 메모리는 데이터를 저장할 수 있는 메모리 셀의 집합체다. 메모리 셀 하나의 크기는 1바이트이다.
> 컴퓨터는 1바이트 단위로 데이터를 저장하고 읽어들인다.

> 각 셀은 고유의 메모리 주소를 갖는다. 이 메모리 주소는 메모리 공간의 위치를 나타내며,
> 0부터 메모리의 크기만큼 정수로 표현된다. 4GB 메모리는 0부터 4,294,967,295까지의 메모리 주소를 갖는다.

> 컴퓨터는 모든 데이털르 2진수로 처리한다.

> 10 + 20 연산 결과 30이 저장된 메모리 공간에 직접 접근하는 것 외에는 방법이 없다.
> 하지만 메모리 주소를 통해 값에 직접 접근하는 것은 치명적 오류를 발생시킬 가능성이 높다.

> 프로그래밍 언어는 기억하고 싶은 값을 메모리에 저장하고, 저장된 값을 읽어 들여 재사용하기 위해 변수라는 메커니즘을 제공한다.
> 변수의 정의를 내려보면 다음과 같다.
#
> **변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 공간을 식별하기 위해 붙인 이름**

> 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름을 변수 이름이라 한다.
> 변수에 저장된 값을 변수 값이라 한다.

> 변수에 값을 저장하는 것을 할당이라 하고, 변수에 저장된 값을 읽어 들이는 것을 참조라 한다.

> **뱐스 이름은 첫아이 이름을 짓듯이 심사숙고해서 지어야 한다.**

## 느낀 점

컴퓨터 공학과 1학년 첫 수업을 들으면 이런 수업을 할까?

프로그래밍의 첫 개념을 여기서 다시 보고가다니..

## 4.2 식별자
> 변수 이름을 식별자 라고도 한다. 식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다.
> 식별자는 값이 아니라 메모리 주소를 기억하고 있다.

## 4.3 변수 선언
> 변수 선언이란 변수를 생성하는 것을 말한다. 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간의
> 주소를 연결해서 값을 저장할 수 있게 준비하는 것이다.

> 변수 선언에 의해 확보된 메모리 공간은 확보가 해제되기 전까지 누구도 확보된 메모리 공간을 사용할 수 없도록 보호되므로
> 안전하게 사용할 수 있다.

> JS는 변수를 선언할 때 var, let, const 키워드를 사용한다.

> var 키워드를 사용한 변수 선언은 선언 단계와 초기화 단계가 동시에 진행된다.
> 초기화 단계를 통해 scope 변수에 암묵적으로 undefined를 할당해 초기화한다.

> 암묵적으로 초기화란 변수가 선언된 이후 최초로 값을 할당하는 것을 말한다.

> 초기화 단계를 거치지 않으면 확보된 메모리 공간에는 이전에 다른 애플리케이션이 사용했던 값이 남아 있을 수 있다.
> 이러한 값을 쓰레기 값이라 한다. 자바스크립트의 var 키워드는 암묵적으로 초기화를 수행하므로 쓰레기 값을 호출 할 일은 없다.

> 변수 사용을 위해서는 반드시 선언이 필요하다. 만약 선언하지 않은 식별자에 접근시
> ReferenceError 가 발생한다.

## 4.5 변수 선언의 실행 시점과 변수 호이스팅

```javascript
console.log(score);

var score;
```

> 자바스크립트 코든느 인터프리터 언어이므로 한 줄씩 순차실행되므로
> log가 먼저 실행되고 순차적으로 다음 줄에 있는 코드를 실행한다.
> log가 실행되는 시점에는 아직 score 변수의 선언이 실행되지 않았으므로 참조 에러가 발생할 것처럼 보인다.
> 하지만 참조 에러는 발생하지 않고 undefined가 출력된다.

> 이유는 변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점, 즉 런타임이 아니라 그 이전 단계에서 먼저 실행되기 떄문이다.

> 자바스크립트 엔진은 변수 선언이 어디에 있든 상관없이 코드보다 먼저 실행한다.

> 이는 변수 선언이 소스코드가 순차적으로 실행되는 런타임 이전 단계에서 먼저 실행된다는 증거이다.
> 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징 (호이스팅)이라 한다.


## 4.5 값의 할당

> 변수에 값을 할당 할 때는 할당 연산자 =를 사용한다.
```javascript
var score = 40;
```

> 변수 선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만.

> 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다.

## 4.6 값의 재할당
> 재할당이란 이미 값이 할당되어 있는 변수에 새로운 값을 또다시 할당하는 것을 말한다.

> 재할당은 변수에 저장된 값을 다른 값으로 변경한다. 이래서 변수라고 하는 것이다.

> 만약 값을 재할당할 수 없다면 변수가 아니라 **상수** 이다.

```javascript
var score;
score = 80;
score = 90;
```

> 현재 변수의 값은 90이다. 이전 값의 undefined, 80은 어떤 변수도 값으로 갖고 있지 않다.
> 다시 말해, 어떤 식별자와도 연결되어 있지 않다.
> 이러한 불필요한 값들은 가비지 컬렉터에서 메로리에서 자동 해제된다.
> 다만 언제 해제될지는 예측할 수 없다.

> 프로그래밍 언어는 메모리 관리 방식에 따라 언매니지드 언어와 매니지드 언어로 분류할 수 있다.
> C 언어 같은 언매니지드 언어는 개발자가 명시적으로 메모리를 할당하고 해제하기 위해 malloc(), free() 같은 저수준 메모리 제어 기능을 제공한다.
> 언매니지드 언어는 메모리 제어를 개발자가 주도할 수 있으므로 개발자의 역량에 따라 최적의 성능을 확보할 수 있지만,
> 반대로 치명적 오류가 발생할 수 있다.

> 자바스크립트 같은 매니지드 언어는 메모리의 할당 및 해제를 위한 메모리 관리 기능을 언어 차원에서 담당하고 개발자의 직접적인 메로리 제어를 허용하지 않는다.

## 느낀 점
그래도 ES.NEXT 에서 나오는 기능을 보면 WeakRef 같은 기능을 사용하여 가비지 컬렉터의 메모리를 어느정도 컨트롤하던데

아예 다른 느낌일까?

